//
// File generated by rootcint at Fri Aug  8 12:11:45 2014

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME sourcedItempdIRootDict
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "RootDict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::string, ::string > pairlEstringcOstringgR;
      #else
      class pairlEstringcOstringgR  {
         public:
         //friend XX;
         string first; //
         string second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const ::string, ::string > pairlEconstsPstringcOstringgR;
      #else
      class pairlEconstsPstringcOstringgR  {
         public:
         //friend XX;
          string first; //
         string second; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void pairlEstringcOstringgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void pairlEstringcOstringgR_Dictionary();
   static void *new_pairlEstringcOstringgR(void *p = 0);
   static void *newArray_pairlEstringcOstringgR(Long_t size, void *p);
   static void delete_pairlEstringcOstringgR(void *p);
   static void deleteArray_pairlEstringcOstringgR(void *p);
   static void destruct_pairlEstringcOstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,string>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<string,string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,string>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,string>", "prec_stl/utility", 17,
                  typeid(pair<string,string>), DefineBehavior(ptr, ptr),
                  &pairlEstringcOstringgR_ShowMembers, &pairlEstringcOstringgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,string>) );
      instance.SetNew(&new_pairlEstringcOstringgR);
      instance.SetNewArray(&newArray_pairlEstringcOstringgR);
      instance.SetDelete(&delete_pairlEstringcOstringgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOstringgR);
      instance.SetDestructor(&destruct_pairlEstringcOstringgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<string,string>*)
   {
      return GenerateInitInstanceLocal((pair<string,string>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<string,string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEstringcOstringgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<string,string>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPstringcOstringgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void pairlEconstsPstringcOstringgR_Dictionary();
   static void *new_pairlEconstsPstringcOstringgR(void *p = 0);
   static void *newArray_pairlEconstsPstringcOstringgR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOstringgR(void *p);
   static void deleteArray_pairlEconstsPstringcOstringgR(void *p);
   static void destruct_pairlEconstsPstringcOstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,string>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const string,string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,string>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,string>", "prec_stl/utility", 17,
                  typeid(pair<const string,string>), DefineBehavior(ptr, ptr),
                  &pairlEconstsPstringcOstringgR_ShowMembers, &pairlEconstsPstringcOstringgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,string>) );
      instance.SetNew(&new_pairlEconstsPstringcOstringgR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOstringgR);
      instance.SetDelete(&delete_pairlEconstsPstringcOstringgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOstringgR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOstringgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const string,string>*)
   {
      return GenerateInitInstanceLocal((pair<const string,string>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const string,string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPstringcOstringgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const string,string>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void allocatorlEpairlEconstsPstringcOstringgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void allocatorlEpairlEconstsPstringcOstringgRsPgR_Dictionary();
   static void *new_allocatorlEpairlEconstsPstringcOstringgRsPgR(void *p = 0);
   static void *newArray_allocatorlEpairlEconstsPstringcOstringgRsPgR(Long_t size, void *p);
   static void delete_allocatorlEpairlEconstsPstringcOstringgRsPgR(void *p);
   static void deleteArray_allocatorlEpairlEconstsPstringcOstringgRsPgR(void *p);
   static void destruct_allocatorlEpairlEconstsPstringcOstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const allocator<pair<const string,string> >*)
   {
      allocator<pair<const string,string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(allocator<pair<const string,string> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("allocator<pair<const string,string> >", "prec_stl/memory", 31,
                  typeid(allocator<pair<const string,string> >), DefineBehavior(ptr, ptr),
                  0, &allocatorlEpairlEconstsPstringcOstringgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(allocator<pair<const string,string> >) );
      instance.SetNew(&new_allocatorlEpairlEconstsPstringcOstringgRsPgR);
      instance.SetNewArray(&newArray_allocatorlEpairlEconstsPstringcOstringgRsPgR);
      instance.SetDelete(&delete_allocatorlEpairlEconstsPstringcOstringgRsPgR);
      instance.SetDeleteArray(&deleteArray_allocatorlEpairlEconstsPstringcOstringgRsPgR);
      instance.SetDestructor(&destruct_allocatorlEpairlEconstsPstringcOstringgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const allocator<pair<const string,string> >*)
   {
      return GenerateInitInstanceLocal((allocator<pair<const string,string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const allocator<pair<const string,string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void allocatorlEpairlEconstsPstringcOstringgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const allocator<pair<const string,string> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator_Dictionary();
   static void *new_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void *p = 0);
   static void *newArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(Long_t size, void *p);
   static void delete_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void *p);
   static void deleteArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void *p);
   static void destruct_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*)
   {
      ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator),0);
      static ::ROOT::TGenericClassInfo 
         instance("map<string,string,less<string>,allocator<pair<const string,string> > >::iterator", "prec_stl/map", 103,
                  typeid(::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator), DefineBehavior(ptr, ptr),
                  0, &maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator_Dictionary, isa_proxy, 0,
                  sizeof(::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator) );
      instance.SetNew(&new_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator);
      instance.SetNewArray(&newArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator);
      instance.SetDelete(&delete_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator);
      instance.SetDeleteArray(&deleteArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator);
      instance.SetDestructor(&destruct_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*)
   {
      return GenerateInitInstanceLocal((::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator_Dictionary();
   static void delete_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator(void *p);
   static void deleteArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator(void *p);
   static void destruct_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*)
   {
      ::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator),0);
      static ::ROOT::TGenericClassInfo 
         instance("map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator", "prec_stl/map", 147,
                  typeid(::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator), DefineBehavior(ptr, ptr),
                  0, &maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator_Dictionary, isa_proxy, 0,
                  sizeof(::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator) );
      instance.SetDelete(&delete_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator);
      instance.SetDeleteArray(&deleteArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator);
      instance.SetDestructor(&destruct_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*)
   {
      return GenerateInitInstanceLocal((::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void pairlEstringcOstringgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class pair<string,string>.
      typedef ::ROOT::Shadow::pairlEstringcOstringgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<string,string>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "first", (void*)&sobj->first);
      R__insp.InspectMember("string", (void*)&sobj->first, "first.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "second", (void*)&sobj->second);
      R__insp.InspectMember("string", (void*)&sobj->second, "second.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,string> : new pair<string,string>;
   }
   static void *newArray_pairlEstringcOstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,string>[nElements] : new pair<string,string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOstringgR(void *p) {
      delete ((pair<string,string>*)p);
   }
   static void deleteArray_pairlEstringcOstringgR(void *p) {
      delete [] ((pair<string,string>*)p);
   }
   static void destruct_pairlEstringcOstringgR(void *p) {
      typedef pair<string,string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,string>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPstringcOstringgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class pair<const string,string>.
      typedef ::ROOT::Shadow::pairlEconstsPstringcOstringgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const string,string>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "first", (void*)&sobj->first);
      R__insp.InspectMember("const string", (void*)&sobj->first, "first.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "second", (void*)&sobj->second);
      R__insp.InspectMember("string", (void*)&sobj->second, "second.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,string> : new pair<const string,string>;
   }
   static void *newArray_pairlEconstsPstringcOstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,string>[nElements] : new pair<const string,string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOstringgR(void *p) {
      delete ((pair<const string,string>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOstringgR(void *p) {
      delete [] ((pair<const string,string>*)p);
   }
   static void destruct_pairlEconstsPstringcOstringgR(void *p) {
      typedef pair<const string,string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_allocatorlEpairlEconstsPstringcOstringgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) allocator<pair<const string,string> > : new allocator<pair<const string,string> >;
   }
   static void *newArray_allocatorlEpairlEconstsPstringcOstringgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) allocator<pair<const string,string> >[nElements] : new allocator<pair<const string,string> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_allocatorlEpairlEconstsPstringcOstringgRsPgR(void *p) {
      delete ((allocator<pair<const string,string> >*)p);
   }
   static void deleteArray_allocatorlEpairlEconstsPstringcOstringgRsPgR(void *p) {
      delete [] ((allocator<pair<const string,string> >*)p);
   }
   static void destruct_allocatorlEpairlEconstsPstringcOstringgRsPgR(void *p) {
      typedef allocator<pair<const string,string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class allocator<pair<const string,string> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator : new ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator;
   }
   static void *newArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator[nElements] : new ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void *p) {
      delete ((::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*)p);
   }
   static void deleteArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void *p) {
      delete [] ((::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*)p);
   }
   static void destruct_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void *p) {
      typedef ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::map<string,string,less<string>,allocator<pair<const string,string> > >::iterator

namespace ROOT {
   // Wrapper around operator delete
   static void delete_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator(void *p) {
      delete ((::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*)p);
   }
   static void deleteArray_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator(void *p) {
      delete [] ((::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*)p);
   }
   static void destruct_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator(void *p) {
      typedef ::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator

namespace ROOT {
   void maplEstringcOstringgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void maplEstringcOstringgR_Dictionary();
   static void *new_maplEstringcOstringgR(void *p = 0);
   static void *newArray_maplEstringcOstringgR(Long_t size, void *p);
   static void delete_maplEstringcOstringgR(void *p);
   static void deleteArray_maplEstringcOstringgR(void *p);
   static void destruct_maplEstringcOstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,string>*)
   {
      map<string,string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,string>),0);
      static ::ROOT::TGenericClassInfo 
         instance("map<string,string>", -2, "prec_stl/map", 63,
                  typeid(map<string,string>), DefineBehavior(ptr, ptr),
                  0, &maplEstringcOstringgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,string>) );
      instance.SetNew(&new_maplEstringcOstringgR);
      instance.SetNewArray(&newArray_maplEstringcOstringgR);
      instance.SetDelete(&delete_maplEstringcOstringgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOstringgR);
      instance.SetDestructor(&destruct_maplEstringcOstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,string> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<string,string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplEstringcOstringgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const map<string,string>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) map<string,string> : new map<string,string>;
   }
   static void *newArray_maplEstringcOstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) map<string,string>[nElements] : new map<string,string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOstringgR(void *p) {
      delete ((map<string,string>*)p);
   }
   static void deleteArray_maplEstringcOstringgR(void *p) {
      delete [] ((map<string,string>*)p);
   }
   static void destruct_maplEstringcOstringgR(void *p) {
      typedef map<string,string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,string>

/********************************************************
* source/temp/RootDict.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableRootDict();

extern "C" void G__set_cpp_environmentRootDict() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__cpp_reset_tagtableRootDict();
}
#include <new>
extern "C" int G__cpp_dllrevRootDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* pair<string,string> */
static int G__RootDict_395_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,string>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,string>[n];
     } else {
       p = new((void*) gvp) pair<string,string>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,string>;
     } else {
       p = new((void*) gvp) pair<string,string>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_395_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,string>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<string,string>(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
   } else {
     p = new((void*) gvp) pair<string,string>(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__RootDict_395_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<string,string>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<string,string>(*(pair<string,string>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<string,string> G__TpairlEstringcOstringgR;
static int G__RootDict_395_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<string,string>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<string,string>*) (soff+(sizeof(pair<string,string>)*i)))->~G__TpairlEstringcOstringgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<string,string>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<string,string>*) (soff))->~G__TpairlEstringcOstringgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const string,string> */
static int G__RootDict_396_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,string>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,string>[n];
     } else {
       p = new((void*) gvp) pair<const string,string>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,string>;
     } else {
       p = new((void*) gvp) pair<const string,string>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_396_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,string>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const string,string>(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
   } else {
     p = new((void*) gvp) pair<const string,string>(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__RootDict_396_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const string,string>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const string,string>(*(pair<const string,string>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const string,string> G__TpairlEconstsPstringcOstringgR;
static int G__RootDict_396_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const string,string>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const string,string>*) (soff+(sizeof(pair<const string,string>)*i)))->~G__TpairlEconstsPstringcOstringgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const string,string>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const string,string>*) (soff))->~G__TpairlEconstsPstringcOstringgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* allocator<pair<const string,string> > */
static int G__RootDict_397_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   allocator<pair<const string,string> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new allocator<pair<const string,string> >[n];
     } else {
       p = new((void*) gvp) allocator<pair<const string,string> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new allocator<pair<const string,string> >;
     } else {
       p = new((void*) gvp) allocator<pair<const string,string> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_397_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   allocator<pair<const string,string> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new allocator<pair<const string,string> >(*(allocator<pair<const string,string> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) allocator<pair<const string,string> >(*(allocator<pair<const string,string> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_397_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const allocator<pair<const string,string> >*) G__getstructoffset())->address(*(pair<const string,string>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_397_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const allocator<pair<const string,string> >*) G__getstructoffset())->address(*(pair<const string,string>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_397_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 85, (long) ((allocator<pair<const string,string> >*) G__getstructoffset())->allocate((allocator<pair<const string,string> >::size_type) G__int(libp->para[0]), (void*) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 85, (long) ((allocator<pair<const string,string> >*) G__getstructoffset())->allocate((allocator<pair<const string,string> >::size_type) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_397_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((allocator<pair<const string,string> >*) G__getstructoffset())->deallocate((allocator<pair<const string,string> >::pointer) G__int(libp->para[0]), (allocator<pair<const string,string> >::size_type) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_397_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const allocator<pair<const string,string> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_397_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((allocator<pair<const string,string> >*) G__getstructoffset())->construct((allocator<pair<const string,string> >::pointer) G__int(libp->para[0]), *(pair<const string,string>*) libp->para[1].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_397_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((allocator<pair<const string,string> >*) G__getstructoffset())->destroy((allocator<pair<const string,string> >::pointer) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef allocator<pair<const string,string> > G__TallocatorlEpairlEconstsPstringcOstringgRsPgR;
static int G__RootDict_397_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (allocator<pair<const string,string> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((allocator<pair<const string,string> >*) (soff+(sizeof(allocator<pair<const string,string> >)*i)))->~G__TallocatorlEpairlEconstsPstringcOstringgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (allocator<pair<const string,string> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((allocator<pair<const string,string> >*) (soff))->~G__TallocatorlEpairlEconstsPstringcOstringgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__RootDict_397_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   allocator<pair<const string,string> >* dest = (allocator<pair<const string,string> >*) G__getstructoffset();
   const allocator<pair<const string,string> >& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* map<string,string,less<string>,allocator<pair<const string,string> > > */
static int G__RootDict_398_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<string,string,less<string>,allocator<pair<const string,string> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new map<string,string,less<string>,allocator<pair<const string,string> > >[n];
     } else {
       p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new map<string,string,less<string>,allocator<pair<const string,string> > >;
     } else {
       p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<string,string,less<string>,allocator<pair<const string,string> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<string,string,less<string>,allocator<pair<const string,string> > >(*((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[0])), *((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >(*((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[0])), *((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<string,string,less<string>,allocator<pair<const string,string> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<string,string,less<string>,allocator<pair<const string,string> > >(*((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__int(libp->para[0])), *((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >(*((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__int(libp->para[0])), *((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<string,string,less<string>,allocator<pair<const string,string> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<string,string,less<string>,allocator<pair<const string,string> > >(*(map<string,string,less<string>,allocator<pair<const string,string> > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >(*(map<string,string,less<string>,allocator<pair<const string,string> > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->operator=(*(map<string,string,less<string>,allocator<pair<const string,string> > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->begin();
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->end();
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->rbegin();
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->rend();
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->operator[](*(string*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         pair<map<string,string,less<string>,allocator<pair<const string,string> > >::iterator,bool>* pobj;
         pair<map<string,string,less<string>,allocator<pair<const string,string> > >::iterator,bool> xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->insert(*(map<string,string,less<string>,allocator<pair<const string,string> > >::value_type*) libp->para[0].ref);
         pobj = new pair<map<string,string,less<string>,allocator<pair<const string,string> > >::iterator,bool>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->insert(*((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[0])), *(map<string,string,less<string>,allocator<pair<const string,string> > >::value_type*) libp->para[1].ref);
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->insert(*((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[0])), *((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->insert(*((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__int(libp->para[0])), *((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->erase(*((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->erase(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->erase(*((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[0])), *((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->swap(*(map<string,string,less<string>,allocator<pair<const string,string> > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->find(*(string*) libp->para[0].ref);
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->count(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->lower_bound(*(string*) libp->para[0].ref);
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_398_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >*) G__getstructoffset())->upper_bound(*(string*) libp->para[0].ref);
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef map<string,string,less<string>,allocator<pair<const string,string> > > G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR;
static int G__RootDict_398_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (map<string,string,less<string>,allocator<pair<const string,string> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((map<string,string,less<string>,allocator<pair<const string,string> > >*) (soff+(sizeof(map<string,string,less<string>,allocator<pair<const string,string> > >)*i)))->~G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (map<string,string,less<string>,allocator<pair<const string,string> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((map<string,string,less<string>,allocator<pair<const string,string> > >*) (soff))->~G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* map<string,string,less<string>,allocator<pair<const string,string> > >::iterator */
static int G__RootDict_399_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator[n];
     } else {
       p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >::iterator[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator;
     } else {
       p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >::iterator;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(*(map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(*(map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >::iterator& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator=(*(map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >::value_type& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >::iterator& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator++();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator++((int) G__int(libp->para[0]));
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >::iterator& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator--();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator--((int) G__int(libp->para[0]));
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator==(*(map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_399_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) G__getstructoffset())->operator!=(*(map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef map<string,string,less<string>,allocator<pair<const string,string> > >::iterator G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator;
static int G__RootDict_399_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) (soff+(sizeof(map<string,string,less<string>,allocator<pair<const string,string> > >::iterator)*i)))->~G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*) (soff))->~G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator */
static int G__RootDict_400_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator(*(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator(*(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_400_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__getstructoffset())->operator=(*(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_400_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >::value_type& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_400_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_400_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__getstructoffset())->operator++();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_400_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__getstructoffset())->operator++((int) G__int(libp->para[0]));
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_400_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator& obj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__getstructoffset())->operator--();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict_400_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator* pobj;
         map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator xobj = ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) G__getstructoffset())->operator--((int) G__int(libp->para[0]));
         pobj = new map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator;
static int G__RootDict_400_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) (soff+(sizeof(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator)*i)))->~G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) (soff))->~G__TmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__RootDict__0_1677(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) libp->para[0].ref, *(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__RootDict__0_1678(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) libp->para[0].ref, *(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* pair<string,string> */

/* pair<const string,string> */

/* allocator<pair<const string,string> > */

/* map<string,string,less<string>,allocator<pair<const string,string> > > */

/* map<string,string,less<string>,allocator<pair<const string,string> > >::iterator */

/* map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncRootDict {
 public:
  G__Sizep2memfuncRootDict(): p(&G__Sizep2memfuncRootDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncRootDict::*p)();
};

size_t G__get_sizep2memfuncRootDict()
{
  G__Sizep2memfuncRootDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceRootDict() {

   /* Setting up class inheritance */
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableRootDict() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR),0,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR),256,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR),1,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR),257,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR),0,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("key_type",117,G__get_linked_tagnum(&G__RootDictLN_string),0,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("mapped_type",117,G__get_linked_tagnum(&G__RootDictLN_string),0,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR),0,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("key_compare",117,G__get_linked_tagnum(&G__RootDictLN_lesslEstringgR),0,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("allocator_type",117,G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR),0,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator),256,G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* pair<string,string> */
static void G__setup_memvarpairlEstringcOstringgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR));
   { pair<string,string> *p; p=(pair<string,string>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__RootDictLN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__RootDictLN_string),-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const string,string> */
static void G__setup_memvarpairlEconstsPstringcOstringgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR));
   { pair<const string,string> *p; p=(pair<const string,string>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,1,G__get_linked_tagnum(&G__RootDictLN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__RootDictLN_string),-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* allocator<pair<const string,string> > */
static void G__setup_memvarallocatorlEpairlEconstsPstringcOstringgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   { allocator<pair<const string,string> > *p; p=(allocator<pair<const string,string> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* map<string,string,less<string>,allocator<pair<const string,string> > > */
static void G__setup_memvarmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   { map<string,string,less<string>,allocator<pair<const string,string> > > *p; p=(map<string,string,less<string>,allocator<pair<const string,string> > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* map<string,string,less<string>,allocator<pair<const string,string> > >::iterator */
static void G__setup_memvarmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator));
   { map<string,string,less<string>,allocator<pair<const string,string> > >::iterator *p; p=(map<string,string,less<string>,allocator<pair<const string,string> > >::iterator*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator */
static void G__setup_memvarmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator));
   { map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator *p; p=(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarRootDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncpairlEstringcOstringgR(void) {
   /* pair<string,string> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR));
   G__memfunc_setup("pair<string,string>",1920,G__RootDict_395_0_1, 105, G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<string,string>",1920,G__RootDict_395_0_2, 105, G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a u 'string' - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR), -1, 1, 1, 1, 4, 0, "u 'pair<string,string>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<string,string>", 1920, G__RootDict_395_0_4, (int) ('i'), G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR), -1, 0, 1, 1, 1, 0, "u 'pair<string,string>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<string,string>", 2046, G__RootDict_395_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPstringcOstringgR(void) {
   /* pair<const string,string> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR));
   G__memfunc_setup("pair<const string,string>",2503,G__RootDict_396_0_1, 105, G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const string,string>",2503,G__RootDict_396_0_2, 105, G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a u 'string' - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR), -1, 1, 1, 1, 4, 0, "u 'pair<const string,string>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const string,string>", 2503, G__RootDict_396_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR), -1, 0, 1, 1, 1, 0, "u 'pair<const string,string>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const string,string>", 2629, G__RootDict_396_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncallocatorlEpairlEconstsPstringcOstringgRsPgR(void) {
   /* allocator<pair<const string,string> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR));
   G__memfunc_setup("allocator<pair<const string,string> >",3618,G__RootDict_397_0_1, 105, G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("allocator<pair<const string,string> >",3618,G__RootDict_397_0_2, 105, G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR), -1, 0, 1, 1, 1, 0, "u 'allocator<pair<const string,string> >' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("address",742,G__RootDict_397_0_3, 85, G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR), G__defined_typename("allocator<pair<const string,string> >::pointer"), 0, 1, 1, 1, 8, "u 'pair<const string,string>' 'allocator<pair<const string,string> >::reference' 0 - __x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("address",742,G__RootDict_397_0_4, 85, G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR), G__defined_typename("allocator<pair<const string,string> >::const_pointer"), 0, 1, 1, 1, 8, "u 'pair<const string,string>' 'allocator<pair<const string,string> >::const_reference' 10 - __x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("allocate",837,G__RootDict_397_0_5, 85, G__get_linked_tagnum(&G__RootDictLN_pairlEconstsPstringcOstringgR), -1, 0, 2, 1, 1, 0, 
"k - 'allocator<pair<const string,string> >::size_type' 0 - __n Y - - 10 '0' -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("deallocate",1038,G__RootDict_397_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"U 'pair<const string,string>' 'allocator<pair<const string,string> >::pointer' 0 - __p k - 'allocator<pair<const string,string> >::size_type' 0 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__RootDict_397_0_7, 107, -1, G__defined_typename("allocator<pair<const string,string> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("construct",997,G__RootDict_397_0_8, 121, -1, -1, 0, 2, 1, 1, 0, 
"U 'pair<const string,string>' 'allocator<pair<const string,string> >::pointer' 0 - __p u 'pair<const string,string>' - 11 - __val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("destroy",778,G__RootDict_397_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "U 'pair<const string,string>' 'allocator<pair<const string,string> >::pointer' 0 - __p", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~allocator<pair<const string,string> >", 3744, G__RootDict_397_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__RootDict_397_0_11, (int) ('u'), G__get_linked_tagnum(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR), -1, 1, 1, 1, 1, 0, "u 'allocator<pair<const string,string> >' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR(void) {
   /* map<string,string,less<string>,allocator<pair<const string,string> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR));
   G__memfunc_setup("map<string,string,less<string>,allocator<pair<const string,string> > >",6772,G__RootDict_398_0_1, 105, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<string,string,less<string>,allocator<pair<const string,string> > >",6772,G__RootDict_398_0_2, 105, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 0 - first u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<string,string,less<string>,allocator<pair<const string,string> > >",6772,G__RootDict_398_0_3, 105, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 0 - first u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<string,string,less<string>,allocator<pair<const string,string> > >",6772,G__RootDict_398_0_4, 105, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__RootDict_398_0_5, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__RootDict_398_0_6, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__RootDict_398_0_7, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__RootDict_398_0_8, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__RootDict_398_0_9, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__RootDict_398_0_10, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__RootDict_398_0_11, 107, -1, G__defined_typename("map<string,string,less<string>,allocator<pair<const string,string> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__RootDict_398_0_12, 107, -1, G__defined_typename("map<string,string,less<string>,allocator<pair<const string,string> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__RootDict_398_0_13, 117, G__get_linked_tagnum(&G__RootDictLN_string), -1, 1, 1, 1, 1, 0, "u 'string' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__RootDict_398_0_14, 117, G__get_linked_tagnum(&G__RootDictLN_pairlEmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiteratorcOboolgR), -1, 0, 1, 1, 1, 0, "u 'pair<string,string>' 'map<string,string,less<string>,allocator<pair<const string,string> > >::value_type' 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__RootDict_398_0_15, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 0 - position u 'pair<string,string>' 'map<string,string,less<string>,allocator<pair<const string,string> > >::value_type' 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__RootDict_398_0_16, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 0 - first u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__RootDict_398_0_17, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 0 - first u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__RootDict_398_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__RootDict_398_0_19, 107, -1, G__defined_typename("map<string,string,less<string>,allocator<pair<const string,string> > >::size_type"), 0, 1, 1, 1, 0, "u 'string' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__RootDict_398_0_20, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 0 - first u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__RootDict_398_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >' - 1 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__RootDict_398_0_22, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("find",417,G__RootDict_398_0_23, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'string' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("count",553,G__RootDict_398_0_24, 107, -1, G__defined_typename("map<string,string,less<string>,allocator<pair<const string,string> > >::size_type"), 0, 1, 1, 1, 8, "u 'string' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("lower_bound",1184,G__RootDict_398_0_25, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'string' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("upper_bound",1187,G__RootDict_398_0_26, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'string' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~map<string,string,less<string>,allocator<pair<const string,string> > >", 6898, G__RootDict_398_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator(void) {
   /* map<string,string,less<string>,allocator<pair<const string,string> > >::iterator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator));
   G__memfunc_setup("iterator",874,G__RootDict_399_0_1, 105, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("iterator",874,G__RootDict_399_0_2, 105, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__RootDict_399_0_3, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__RootDict_399_0_4, 117, G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR), G__defined_typename("map<string,string,less<string>,allocator<pair<const string,string> > >::value_type"), 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__RootDict_399_0_5, 85, G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR), G__defined_typename("map<string,string,less<string>,allocator<pair<const string,string> > >::value_type"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__RootDict_399_0_6, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__RootDict_399_0_7, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__RootDict_399_0_8, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__RootDict_399_0_9, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__RootDict_399_0_10, 103, -1, -1, 0, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator!=",970,G__RootDict_399_0_11, 103, -1, -1, 0, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >::iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~iterator", 1000, G__RootDict_399_0_12, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator(void) {
   /* map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator));
   G__memfunc_setup("reverse_iterator",1733,G__RootDict_400_0_1, 105, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator), -1, 0, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__RootDict_400_0_2, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator), -1, 1, 1, 1, 1, 0, "u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__RootDict_400_0_3, 117, G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR), G__defined_typename("map<string,string,less<string>,allocator<pair<const string,string> > >::value_type"), 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__RootDict_400_0_4, 85, G__get_linked_tagnum(&G__RootDictLN_pairlEstringcOstringgR), G__defined_typename("map<string,string,less<string>,allocator<pair<const string,string> > >::value_type"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__RootDict_400_0_5, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__RootDict_400_0_6, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator), -1, 0, 1, 1, 1, 0, "i - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__RootDict_400_0_7, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__RootDict_400_0_8, 117, G__get_linked_tagnum(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator), -1, 0, 1, 1, 1, 0, "i - - 0 - a", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~reverse_iterator", 1859, G__RootDict_400_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncRootDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalRootDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
   G__memfunc_setup("operator==", 998, G__RootDict__0_1677, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 11 - x u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__RootDict__0_1678, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 11 - x u 'map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcRootDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__RootDictLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__RootDictLN_lesslEstringgR = { "less<string>" , 115 , -1 };
G__linked_taginfo G__RootDictLN_pairlEstringcOstringgR = { "pair<string,string>" , 115 , -1 };
G__linked_taginfo G__RootDictLN_pairlEconstsPstringcOstringgR = { "pair<const string,string>" , 115 , -1 };
G__linked_taginfo G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR = { "allocator<pair<const string,string> >" , 99 , -1 };
G__linked_taginfo G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR = { "map<string,string,less<string>,allocator<pair<const string,string> > >" , 99 , -1 };
G__linked_taginfo G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator = { "map<string,string,less<string>,allocator<pair<const string,string> > >::iterator" , 99 , -1 };
G__linked_taginfo G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator = { "map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator" , 99 , -1 };
G__linked_taginfo G__RootDictLN_pairlEmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiteratorcOboolgR = { "pair<map<string,string,less<string>,allocator<pair<const string,string> > >::iterator,bool>" , 115 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableRootDict() {
  G__RootDictLN_string.tagnum = -1 ;
  G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__RootDictLN_lesslEstringgR.tagnum = -1 ;
  G__RootDictLN_pairlEstringcOstringgR.tagnum = -1 ;
  G__RootDictLN_pairlEconstsPstringcOstringgR.tagnum = -1 ;
  G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR.tagnum = -1 ;
  G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR.tagnum = -1 ;
  G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator.tagnum = -1 ;
  G__RootDictLN_pairlEmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiteratorcOboolgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableRootDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__RootDictLN_string);
   G__get_linked_tagnum_fwd(&G__RootDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__RootDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__RootDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__RootDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__RootDictLN_lesslEstringgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_pairlEstringcOstringgR),sizeof(pair<string,string>),-1,297216,(char*)NULL,G__setup_memvarpairlEstringcOstringgR,G__setup_memfuncpairlEstringcOstringgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_pairlEconstsPstringcOstringgR),sizeof(pair<const string,string>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPstringcOstringgR,G__setup_memfuncpairlEconstsPstringcOstringgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_allocatorlEpairlEconstsPstringcOstringgRsPgR),sizeof(allocator<pair<const string,string> >),-1,263936,(char*)NULL,G__setup_memvarallocatorlEpairlEconstsPstringcOstringgRsPgR,G__setup_memfuncallocatorlEpairlEconstsPstringcOstringgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR),sizeof(map<string,string,less<string>,allocator<pair<const string,string> > >),-1,298752,(char*)NULL,G__setup_memvarmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR,G__setup_memfuncmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator),sizeof(map<string,string,less<string>,allocator<pair<const string,string> > >::iterator),-1,2816,(char*)NULL,G__setup_memvarmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator,G__setup_memfuncmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiterator);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__RootDictLN_maplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator),sizeof(map<string,string,less<string>,allocator<pair<const string,string> > >::reverse_iterator),-1,2560,(char*)NULL,G__setup_memvarmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator,G__setup_memfuncmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLreverse_iterator);
   G__get_linked_tagnum_fwd(&G__RootDictLN_pairlEmaplEstringcOstringcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOstringgRsPgRsPgRcLcLiteratorcOboolgR);
}
extern "C" void G__cpp_setupRootDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupRootDict()");
  G__set_cpp_environmentRootDict();
  G__cpp_setup_tagtableRootDict();

  G__cpp_setup_inheritanceRootDict();

  G__cpp_setup_typetableRootDict();

  G__cpp_setup_memvarRootDict();

  G__cpp_setup_memfuncRootDict();
  G__cpp_setup_globalRootDict();
  G__cpp_setup_funcRootDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncRootDict();
  return;
}
class G__cpp_setup_initRootDict {
  public:
    G__cpp_setup_initRootDict() { G__add_setup_func("RootDict",(G__incsetup)(&G__cpp_setupRootDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initRootDict() { G__remove_setup_func("RootDict"); }
};
G__cpp_setup_initRootDict G__cpp_setup_initializerRootDict;

